#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "point.h"
#include "ballnode.h"

#define SUCCESS 1
#define FAILED  0

#define TRUE  1
#define FALSE 0

typedef struct {
    double center_x, center_y, center_z;
    double radius;
    double sum_weight;
    int left, right;
    int data_start, data_end;
} BallNodeSerialized;

typedef struct {
    int size;
    BallNodeSerialized *buffer;
    int *next_free;
} BallNodeBuffer;

typedef struct {
    int size;
    int bytes;
} SectionHeader;

typedef struct {
    int leafsize;
    SectionHeader nodes;
    SectionHeader points;
} FileHeader;

int bnode_serialise_recursive(BallNodeBuffer buffer, BallNode *node, int insertion_index);
BallNode *bnode_deserialise_recursive(BallNodeSerialized *buffer, int buffer_size, const PointBuffer *points, int index);

int bnode_serialise_recursive(BallNodeBuffer buffer, BallNode *node, int insertion_index) {
    if (*buffer.next_free > buffer.size) {
        return FAILED;
    }
    int is_leaf = bnode_is_leaf(node);

    int index_left, index_right;
    if (is_leaf) {
        index_left = -1;
        index_right = -1;
    } else {
        index_left = (*buffer.next_free)++;
        index_right = (*buffer.next_free)++;
    }
    BallNodeSerialized serialized = {
        .center_x = node->center.x,
        .center_y = node->center.y,
        .center_z = node->center.z,
        .radius = node->radius,
        .sum_weight = node->sum_weight,
        .left = index_left,
        .right = index_right,
        .data_start = node->data.start,
        .data_end = node->data.end,
    };
    buffer.buffer[insertion_index] = serialized;

    if (!is_leaf) {
        if (!bnode_serialise_recursive(buffer, node->left, serialized.left)) {
            return FAILED;
        }
        if (!bnode_serialise_recursive(buffer, node->right, serialized.right)) {
            return FAILED;
        }
    }
    return SUCCESS;
}

BallNode *bnode_deserialise_recursive(BallNodeSerialized *buffer, int buffer_size, const PointBuffer *points, int index) {
    if (index >= buffer_size) {
        return NULL;
    }
    BallNode *node = (BallNode *)calloc(sizeof(BallNode), 1);
    if (!node) {
        return NULL;
    }
    BallNodeSerialized *serialized = buffer + index;

    if (serialized->data_end > points->size) {
        fprintf(stderr, "ERROR: point buffer does not match data slice expected by node\n");
        free(node);
        return NULL;
    }
    node->center = point_create(serialized->center_x, serialized->center_y, serialized->center_z);
    node->radius = serialized->radius;
    node->sum_weight = serialized->sum_weight;
    node->data = (PointSlice){
        .start = serialized->data_start,
        .end = serialized->data_end,
        .points = points->points,
    };

    // recurse into potential leaf nodes
    if (serialized->left != -1) {
        node->left = bnode_deserialise_recursive(buffer, buffer_size, points, serialized->left);
        if (!node->left) {
            free(node);
            return NULL;
        }
    }
    if (serialized->right != -1) {
        node->right = bnode_deserialise_recursive(buffer, buffer_size, points, serialized->right);
        if (!node->right) {
            free(node);
            return NULL;
        }
    }
    return node;
}

int balltree_to_file(const BallTree *tree, const char *path) {
    size_t elements_written;
    FILE *file = fopen(path, "wb");
    if (!file) {
        fprintf(stderr, "ERROR: failed to open file\n");
        return FAILED;
    }

    // write the header
    int num_nodes = balltree_count_nodes(tree);
    int num_points = tree->data.size;
    struct FileHeader header = {
        .leafsize = tree->leafsize,
        .nodes = {
            .size = num_nodes,
            .bytes = num_nodes * sizeof(BallNodeSerialized)
        },
        .points = {
            .size = num_points,
            .bytes = num_points * sizeof(Point)
        },
    };
    elements_written = fwrite(&header, sizeof(struct FileHeader), 1, file);
    if (elements_written != 1) {
        fprintf(stderr, "ERROR: failed to write header\n");
        goto close_file;
    }

    // append serialised point buffer
    elements_written = fwrite(tree->data.points, sizeof(Point), header.points.size, file);
    if (elements_written != header.points.size) {
        fprintf(stderr, "ERROR: failed to write data points\n");
        goto close_file;
    }

    // serialise nodes
    int index_tracker = 1;  // 0 is already reserved for root node
    BallNodeBuffer node_buffer = {
        .size = header.nodes.size,
        .next_free = &index_tracker,
    };
    node_buffer.buffer = (BallNodeSerialized*)malloc(header.nodes.bytes);
    if (!node_buffer.buffer) {
        fprintf(stderr, "ERROR: failed to allocate memory for serialized node data\n");
        goto close_file;
    }
    int success = bnode_serialise_recursive(node_buffer, tree->root, 0);
    if (!success) {
        goto dealloc_nodes;
    }

    // append serialised nodes
    elements_written = fwrite(node_buffer.buffer, sizeof(BallNodeSerialized), header.nodes.size, file);
    free(node_buffer.buffer);
    if (elements_written != header.nodes.size) {
        fprintf(stderr, "ERROR: failed to write node data\n");
        goto close_file;
    }

    if (fflush(file) == EOF) {
        fprintf(stderr, "ERROR: failed to flush file\n");
        goto close_file;
    }
    fclose(file);

    return SUCCESS;

    // alternative exit route which cleans up buffers
dealloc_nodes:
    free(node_buffer.buffer);
close_file:
    fclose(file);
    return FAILED;
}

BallTree* balltree_from_file(const char *path) {
    size_t elements_read;
    FILE *file = fopen(path, "rb");
    if (file == NULL) {
        fprintf(stderr, "ERROR: failed to open file\n");
        return NULL;
    }

    // read header
    struct FileHeader header;
    elements_read = fread(&header, sizeof(struct FileHeader), 1, file);
    if (elements_read != 1) {
        fprintf(stderr, "ERROR: failed to read header\n");
        goto close_file;
    }

    // allocate all memory required
    BallTree *tree = (BallTree*)malloc(sizeof(BallTree));
    if (!tree) {
        fprintf(stderr, "ERROR: failed to allocate tree\n");
        goto close_file;
    }
    Point *points = (Point*)malloc(header.points.bytes);
    if (!points) {
        fprintf(stderr, "ERROR: failed to allocate point buffer\n");
        goto dealloc_tree;
    }
    BallNodeSerialized *node_buffer = (BallNodeSerialized *)malloc(header.nodes.bytes);
    if (!node_buffer) {
        fprintf(stderr, "ERROR: failed to allocate node data\n");
        goto dealloc_points;
    }

    // read point buffer
    elements_read = fread(points, sizeof(Point), header.points.size, file);
    if (elements_read != header.points.size) {
        fprintf(stderr, "ERROR: failed to read data points\n");
        goto dealloc_nodes;
    }

    // read node data
    elements_read = fread(node_buffer, sizeof(BallNodeSerialized), header.nodes.size, file);
    if (elements_read != header.nodes.size) {
        fprintf(stderr, "ERROR: failed to read node data\n");
        goto dealloc_nodes;
    }

    // populate the tree
    tree->leafsize = header.leafsize;
    tree->data = (PointBuffer){
        .size = header.points.size,
        .points = points,
    };
    tree->root = bnode_deserialise_recursive(node_buffer, header.nodes.size, &tree->data, 0);
    if (!tree->root) {
        fprintf(stderr, "ERROR: failed to reconstruct tree\n");
        goto dealloc_nodes;
    }

    fclose(file);
    return tree;

    // alternative exit route which cleans up buffers
dealloc_nodes:
    free(node_buffer);
dealloc_points:
    free(points);
dealloc_tree:
    free(tree);
close_file:
    fclose(file);
    return NULL;
}
